using ForwardDiff
using Distances

LR = 0.01 # learning rate
EPOCHS = 1000 # number of epochs
DIM = 2 # dimensionality of embeddings

function radius(x)
    return x[end]
end

function centerpoint(x)
    return x[1:end-1]
end

function loss1(c, d) # loss for normal form 1
    return max(0, euclidean(centerpoint(c), centerpoint(d)) + abs(radius(c))-abs(radius(d)))
end

function loss2(c1, c2, d) # loss for c1 and c2 SubClassOf: d
    dist = euclidean(centerpoint(c1), centerpoint(c2))
    if dist > radius(c1) + radius(c2)
        return radius(c2) + radius(c2) # no solution, circles are separate
    elseif dist < abs(radius(c1)-radius(c2)) # no solution, one circle contained in other
        if radius(c1) <= radius(c2)
            return loss1(c1, d)
        else
            return loss1(c2, d)
        end
    elseif dist == 0 && radius(c1) == radius(c2) ## circles are coincident
        return loss1(c1, d)
    else
        a = (radius(c1)^2 - radius(c2)^2 + dist^2)/(2 * dist)
        rad = sqrt(radius(c1)^2 - a^2)
        cent = centerpoint(c1) + a * (centerpoint(c2) - centerpoint(c1)) / dist
        return loss1(vcat(cent, rad),d)
    end
end

function loss3(c, d, r) # normal form 3
    return max(0, euclidean(centerpoint(c)-r, centerpoint(d)) + abs(radius(d)) - abs(radius(c)))
end

function loss4(c, d, r) # normal form 4
    return max(0, euclidean(centerpoint(c)+r, centerpoint(d)) + abs(radius(d)) - abs(radius(c)))
end

classes = Dict()
relations = Dict()
ccount = 1
rcount = 1

function filldict(x)
    global ccount
    if haskey(classes, x)
        return classes[x]
    else
        classes[x] = ccount
        ccount += 1
        return ccount - 1
    end
end

function rfilldict(x)
    global rcount
    if haskey(relations, x)
        return relations[x]
    else
        relations[x] = rcount
        rcount += 1
        return rcount - 1
    end
end

nf1 = Set()
nf2 = Set()
nf3 = Set()
nf4 = Set()

# Reading the file of normalized axioms (generated by Normalize.groovy)
open(ARGS[1]) do file
    for line in eachline(file)
        if (startswith(line, "SubClassOf")) # ignore subproperty axioms
            if occursin(r"ObjectIntersectionOf", line) # normal form 2
                m = match(r"(<.*>).*(<.*>).*(<.*>)", line) # 3 captures: C and D SubClassOf: E
                if m != nothing
                    c, d, e = map(filldict, m.captures)
                    push!(nf2, (c,d,e))
                end
            elseif occursin(r"SubClassOf.<[^\s]*>[\s]*<[^\s]*>.$", line) # normal form 1
                m = match(r"(<.*>).*(<.*>)", line) # 2 captures: C SubClassOf: D
                c,d = map(filldict, m.captures)
                push!(nf1, (c,d))
            elseif occursin(r"SubClassOf.ObjectSomeValuesFrom", line)  # normal form 4
                m = match(r"(<.*>).*(<.*>).*(<.*>)", line) # 3 captures: R some C SubClassOf: D
                r,c,d = m.captures
                c = filldict(c)
                d = filldict(d)
                r = rfilldict(r)
                push!(nf4, (r,c,d))
            elseif occursin(r"SubClassOf.<[^\s]*>[\s]*ObjectSomeValuesFrom", line)  # normal form 3
                m = match(r"(<.*>).*(<.*>).*(<.*>)", line) # 3 captures: C SubClassOf: R some D
                c,r,d = m.captures
                c = filldict(c)
                d = filldict(d)
                r = rfilldict(r)
                push!(nf3, (c,r,d))
            end
        end
    end
end

# there are now rcount-1 relations and ccount-1 classes; generate random embeddings
cvec = rand(ccount-1, DIM + 1)
rvec = rand(rcount-1, DIM)

par = rand(3)
child = rand(3)
male = rand(3)
hasChild = rand(2)

q(x) = loss2(x, par, male)
t(x) = ForwardDiff.gradient(q, x)
for i in 1:EPOCHS
    global child
    child = child - t(child) * LR
    println(radius(child))
end
